//Noah Petzinger
//May 24, 2023
//Program to parse data from stock files generated by GenerateStockFiles.cpp

#include <fstream>
#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <numeric>
#include <algorithm>
#include <dirent.h>
#include <sys/types.h>

using namespace std;

string directoryName = "StockFiles";

//Function to generate list of filenames in StockFiles
vector<string> GetFileNames(string directoryName);

vector<vector<string>> GetStockInfo(string fileName);
vector<float> GetTimeDifferences(vector<float> tradeTimes);

//functions dealing with time between trades
vector<float> GetTradeTimes(vector<vector<string>> stockInfo);

//function to find tick times
vector<float> GetTickTimes(vector<vector<string>> stockInfo);

//helper functions
float FindMean(vector<float> v);
float FindMedian(vector<float> v);
void PrintVector(vector<string> v);
void PrintFloatVector(vector<float> v);
void AddToFile(vector<string> row);

//bid-ask spread function
vector<float> GetBidAskSpreads(vector<vector<string>> stockInfo);

//function to gather trade values and volumes
vector<vector<float>> GetValuesAndVolumes(vector<vector<string>> stockInfo);
vector<float> RoundNumberEffect(vector<vector<float>> valuesAndVolumes);


int main()
{
    vector<string> fileNames = GetFileNames(directoryName);

    //iterate through every file in the list, then add the results to a csv
    for (int i = 0; i < fileNames.size(); i++)
    {
        string fileName = directoryName + '/' + fileNames[i];

        vector<string> findings;

        //holds all the information for the stock in a list of string vectors
        vector<vector<string>> stockInfo;

        //holds data on all trade/tick time differences
        vector<float> tradeTimeDifferences;
        vector<float> tickTimeDifferences;

        //vector that holds only the time stamp of each trade/tick
        vector<float> tradeTimes;
        vector<float> tickTimes;

        stockInfo = GetStockInfo(fileName);

        //get the mean, median, and longest trade times
        tradeTimes = GetTradeTimes(stockInfo);
        tradeTimeDifferences = GetTimeDifferences(tradeTimes);

        float meanTimeBetweenTrades = FindMean(tradeTimeDifferences);
        float medianTimeBetweenTrades = FindMedian(tradeTimeDifferences);
        float longestTimeBetweenTrades = *max_element(tradeTimeDifferences.begin(), tradeTimeDifferences.end());

        //get the mean, median, and longest tick times
        tickTimes = GetTickTimes(stockInfo);
        tickTimeDifferences = GetTimeDifferences(tickTimes);

        float meanTimeBetweenTicks = FindMean(tickTimeDifferences);
        float medianTimeBetweenTicks = FindMedian(tickTimeDifferences);
        float longestTimeBetweenTicks = *max_element(tickTimeDifferences.begin(), tickTimeDifferences.end());

        //get the mean and median bid ask spreads
        vector<float> bidAskSpreads = GetBidAskSpreads(stockInfo);

        float meanBidAskSpread = FindMean(bidAskSpreads);
        float medianBidAskSpread = FindMedian(bidAskSpreads);

        //round number effect for values and volumes
        vector<vector<float>> valuesAndVolumes = GetValuesAndVolumes(stockInfo);
        vector<float> roundNumEffect = RoundNumberEffect(valuesAndVolumes);

        //generate result list
        findings.push_back(stockInfo[0][0]);
        findings.push_back(to_string(meanTimeBetweenTrades));
        findings.push_back(to_string(medianTimeBetweenTrades));
        findings.push_back(to_string(meanTimeBetweenTicks));
        findings.push_back(to_string(medianTimeBetweenTicks));
        findings.push_back(to_string(longestTimeBetweenTrades));
        findings.push_back(to_string(longestTimeBetweenTicks));
        findings.push_back(to_string(meanBidAskSpread));
        findings.push_back(to_string(medianBidAskSpread));
        findings.push_back(to_string(roundNumEffect[0]));
        findings.push_back(to_string(roundNumEffect[1]));

        //Finally, push results vector to the file
        AddToFile(findings);    
    }

    return 0;
}

//Function to gather info from the .csv file into a usable vector<vector<string>> object
vector<vector<string>> GetStockInfo(string fileName)
{
    ifstream fin;

    fin.open(fileName, ios::in);

    //vector of vector strings to hold info on stocks
    //each vector in the list contains one tick of data
    vector<vector<string>> stockInfo;
    vector<string> row;
    string line, word;

    int ctr = 0;

    if (fin.is_open())
    {
        while (getline(fin, line))
        {
            row.clear();
            ctr += 1;

            stringstream str(line);

            while(getline(str, word, ','))
            {
                row.push_back(word);
            }

            stockInfo.push_back(row);
        }

        return stockInfo;
    }

    else
    {
        cout << "Failed to Open File" << endl;
        return stockInfo;
    }
}

//Function to extract only the trade times from stockInfo
vector<float> GetTradeTimes(vector<vector<string>> stockInfo)
{
    vector<float> tradeTimes;

    //iterate through all rows, extracting times and storing them in a vector
    for(int i = 0; i < stockInfo.size(); i++)
    {
        //ensure that row is a trade by checking the Update Type Field
        if (stockInfo[i][8] == "1")
        {
            //also check for special auction codes
            if (stockInfo[i][14] == "" || stockInfo[i][14] == "XT")
                tradeTimes.push_back(stof(stockInfo[i][11]));
        }
    }

    return tradeTimes;
}

void PrintVector(vector<string> v)
{
    for(int i = 0; i < v.size(); i++)
    {
        cout << v[i];
        if (i != v.size()-1)
            cout << ',';
    }
    cout << '\n';
}

void PrintFloatVector(vector<float> v)
{
    for(int i = 0; i < v.size(); i++)
    {
        cout << v[i];
        if (i != v.size()-1)
            cout << ',';
    }
    cout << '\n';

    cout << "List size: " << v.size() << endl;
}

float FindMean(vector<float> v)
{
    float average;

    //find the average time by calculating all the differences in time and dividing by the size of the vector
    float sumOfArray = accumulate(v.begin(), v.end(), 0);
    average = sumOfArray / v.size();

    return average;
}

float FindMedian(vector<float> v)
{
    int n = v.size();

    float median;

    //if size of the array is even
    if (n % 2 == 0)
    {
        //nth_element sorts an array just enough so that the nth element is in the correct spot
        nth_element(v.begin(), v.begin() + n/2, v.end());
        nth_element(v.begin(), v.begin() + (n-1)/2, v.end());

        //find the median
        median = (v[(n-1) / 2] + v[n / 2]) / 2;
    }

    //if size of array is odd
    else
    {
        nth_element(v.begin(), v.begin() + n/2, v.end());

        median = v[n/2];
    }

    return median;
}

//Function to collect the time differences for a list of times
//Special checks are added to deal with stock trades from one day to the next so as not to skew the results
vector<float> GetTimeDifferences(vector<float> times)
{
    vector<float> timeDifferences;

    //generates list of time between trades
    for (int i = 1; i < times.size(); i++)
    {
        //if time is greater than the one before it, add
        //otherwise it means a day has passed, time should not be added in order not to skew results
        if (times[i] > times[i-1])
        {
            timeDifferences.push_back(times[i]-times[i-1]);
        }
    }

    return timeDifferences;
}

//Similar to GetTradeTimes, but collects tick times instead
vector<float> GetTickTimes(vector<vector<string>> stockInfo)
{
    vector<float> tickTimes;

    //iterate through all rows, extracting times and storing them in a vector
    for(int i = 0; i < stockInfo.size(); i++)
    {   
        //ensure that row is a tick change (change in bid or ask price) by checking the Update Type Field
        if (stockInfo[i][8] == "2" || stockInfo[i][8] == "3")
        {
            //also check for special auction codes
            if (stockInfo[i][14] == "" || stockInfo[i][14] == "XT")
                tickTimes.push_back(stof(stockInfo[i][11]));
        }
    }

    return tickTimes;
}

//Function to calculate and return ask spreads for a given stock
vector<float> GetBidAskSpreads(vector<vector<string>> stockInfo)
{
    vector<float> spreads;

    //iterate through all rows, extracting times and storing them in a vector
    for(int i = 0; i < stockInfo.size(); i++)
    {
        //ensure that row is a change by checking the Update Type Field
        if (stockInfo[i][8] == "1" || stockInfo[i][8] == "2" || stockInfo[i][8] == "3")
        {
            //also check for special auction codes
            if (stockInfo[i][14] == "" || stockInfo[i][14] == "XT")
                spreads.push_back(stof(stockInfo[i][3]) - stof(stockInfo[i][2]));
        }
    }

    return spreads;
}

//Function to get both the trade values and volumes for every trade of a given stock
vector<vector<float>> GetValuesAndVolumes(vector<vector<string>> stockInfo)
{
    vector<vector<float>> allVandV;
    vector<float> singleVandV;


    //iterate through all rows, extracting times and storing them in a vector
    for(int i = 0; i < stockInfo.size(); i++)
    {
        singleVandV.clear();
        //ensure that row is a change by checking the Update Type Field
        if (stockInfo[i][8] == "1")
        {
            //also check for special auction codes
            if (stockInfo[i][14] == "" || stockInfo[i][14] == "XT")
                singleVandV.push_back(stof(stockInfo[i][4]));
                singleVandV.push_back(stof(stockInfo[i][7]));

                allVandV.push_back(singleVandV);
        }
    }

    return allVandV;
}

//iterate through list, keep track of number of digits ending in zero in both trade value and volume
vector<float> RoundNumberEffect(vector<vector<float>> v)
{
    //vector holds two values, first is the percentage of trade values ending in zero, second is percentage of trade volumes ending in zero
    vector<float> ans;

    int zeroDigitValues = 0;
    int zeroDigitVolumes = 0;

    for (int i = 0; i < v.size(); i++)
    {
        if ((int)v[i][0] % 10 == 0)
        {
            zeroDigitValues++;
        }

        if ((int)v[i][1] % 10 == 0)
        {
            zeroDigitVolumes++;
        }
    }

    ans.push_back((float)zeroDigitValues / v.size());
    ans.push_back((float)zeroDigitVolumes / v.size());

    return ans;
}

vector<string> GetFileNames(string directoryName)
{
    vector<string> fileNames;

    DIR *dr;
    struct dirent *en;
    dr = opendir(directoryName.c_str());

    if (dr)
    {
        while ((en = readdir(dr)) != NULL)
        {
            if ((string)en->d_name != ".." && (string)en->d_name != ".")
            {
                fileNames.push_back(en->d_name);
            }
        }
    }

    closedir(dr);
    return fileNames;
}

void AddToFile(vector<string> row)
{
    string fileName = "StockResults.csv";

    ofstream fout;

    fout.open(fileName, ios::app);

    for(int i = 0; i < row.size(); i++)
    {
        fout << row[i];
        if (i != row.size()-1)
            fout << ',';
    }

    fout << '\n';

    fout.close();
}